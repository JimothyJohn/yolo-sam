#!/usr/bin/env bash

set -e
set -o nounset
set -o pipefail

# Ensure ENV is set
export ENV="${ENV:-dev}"

# AI-generated comment: Check for the existence of the dev.env file
if [[ -f ".env.${ENV}" ]]; then
    set -a
    . ".env.${ENV}"
    set +a
fi

if [[ "${TRACE-0}" == "1" ]]; then
    set -o xtrace
fi

# AI-generated comment: Function to log messages with timestamps
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
}

# AI-generated comment: Determine python command
PYTHON_CMD="python"
if [[ -d ".venv" ]]; then
    if [[ -f ".venv/bin/python" ]]; then
        PYTHON_CMD=".venv/bin/python"
    elif [[ -f ".venv/Scripts/python" ]]; then # Windows support just in case
        PYTHON_CMD=".venv/Scripts/python"
    fi
fi

# AI-generated comment: Updated help function
help_function() {
    cat <<EOF

Usage: $(basename "$0") [-h] [-t]

Description:
  This script manages the development, testing, and deployment of AWS SAM-based Lambda functions.

Options:
  -h, --help             Display this help message and exit
  -t, --test             Run ALL tests: unit, integration, and deployment

Examples:
  $(basename "$0") -t                    # Run everything (Unit -> Integration -> Deploy)

Note:
  - Ensure you have sam, AWS SAM CLI, and Python with pip installed.
  - The script will utilize '.venv' if present.
  - For deployment, make sure you have configured your AWS credentials.

EOF
}

# Function to check if a command exists
command_exists() {
    type "$1" &> /dev/null
}

check_dependencies() {
    local missing_deps=()

    if ! command_exists "sam"; then
        missing_deps+=("sam")
    fi

    if ! command_exists "uv"; then
        log "uv not found. Installing..."
        curl -LsSf https://astral.sh/uv/install.sh | sh
        # Attempt to add to path for current session
        if [[ -f "$HOME/.cargo/env" ]]; then
            . "$HOME/.cargo/env"
        elif [[ -f "$HOME/.local/bin/env" ]]; then # Possible alternative location
             . "$HOME/.local/bin/env"
        fi
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        echo "Error: The following required dependencies are missing:"
        printf " - %s\n" "${missing_deps[@]}"
        echo "Please install the missing dependencies and try again."
        exit 1
    fi
    return 0
}

check_and_export_model() {
    # Extract model path from config.py
    # Assuming MODEL_PATH = "models/filename.onnx"
    local config_model_path
    config_model_path=$(grep -E "^MODEL_PATH\s*=" detection/config.py | head -n 1 | cut -d '"' -f 2)

    # If using single quotes, try to catch that too, but simple parsing for now
    if [[ -z "$config_model_path" ]]; then
       # Fallback or try single quotes
       config_model_path=$(grep -E "^MODEL_PATH\s*=" detection/config.py | head -n 1 | cut -d "'" -f 2)
    fi

    if [[ -z "$config_model_path" ]]; then
        log "WARNING: Could not determine MODEL_PATH from detection/config.py. Skipping auto-export."
        return 0
    fi

    local full_model_path="detection/${config_model_path}"

    if [[ ! -f "$full_model_path" ]]; then
        log "Model not found at $full_model_path. Attempting to download..."

        wget -O detection/models/rf-detr-nano.onnx https://huggingface.co/PierreMarieCurie/rf-detr-onnx/resolve/main/rf-detr-nano.onnx

        # Check for ultralytics
        if ! uv run python -c "import ultralytics" &> /dev/null; then
             # Try installing dev dependencies if checks fail?
             # Assuming environment is already set up by validate_and_build -> install -e .
             log "Installing ultralytics for export..."
             uv pip install ultralytics > /dev/null 2>&1
        fi

        # We assume yolov8n.pt -> yolov8n.onnx based on current usage
        # But if config says something else, we might need to adjust.
        # For now, hardcode the export source to yolov8n.pt as per ExportONNX.sh logic
        # Ideally we map config name to pt name, but let's stick to the requested replication of ExportONNX.

        log "Exporting YOLOv8n model to ONNX..."
        if uv run yolo export model=yolov8n.pt format=onnx > /dev/null 2>&1; then
             # Move artifact. 'yolo export' usually outputs to current dir or runs dir.
             # Based on ExportONNX.sh, it expects it in current dir.
             if [[ -f "yolov8n.onnx" ]]; then
                 mkdir -p "$(dirname "$full_model_path")"
                 mv yolov8n.onnx "$full_model_path"
                 log "Model exported successfully to $full_model_path"
                 rm -f yolov8n.pt
             else
                 log "ERROR: Export command succeeded but output file not found."
                 return 1
             fi
        else
            log "ERROR: Model export failed."
            return 1
        fi
    fi
    return 0
}

validate_and_build() {
    log "Setting up environment"
    if ! uv pip install -q -e .; then
        log "ERROR: Environment setup failed"
        return 1
    fi

    if ! uv run ruff check --fix -q; then
        log "ERROR: Code checking failed"
        return 1
    fi

    if ! uv run ruff format -q; then
        log "ERROR: Code formatting failed"
        return 1
    fi

    if ! sam validate --region us-east-1 > /dev/null 2>&1; then
        log "ERROR: SAM template validation failed"
        return 1
    fi

    log "Building application (est. 10s)"
    if ! sam build > /dev/null 2>&1; then
        log "ERROR: SAM build failed"
        return 1
    fi

    return 0
}

test_unit() {
    log "Running unit tests..."
    if ! uv run pytest -q -m unit; then
        log "ERROR: Unit tests failed"
        return 1
    fi

    return 0
}

test_integration() {
    # Check for docker availability
    if ! command_exists "docker" || ! docker info > /dev/null 2>&1; then
        log "WARNING: Docker is not available. Skipping integration tests (SAM Local requires Docker)."
        log "To run integration tests, please install Docker:"
        log "  - macOS: https://www.docker.com/products/docker-desktop/ or 'brew install --cask docker'"
        log "  - Linux: https://docs.docker.com/engine/install/"
        log "  - Windows: https://docs.docker.com/desktop/install/windows-install/"
        return 0
    fi

    log "Running integration test procedure [5s]..."
    sam local start-api --skip-pull-image --log-file .logs/local_api.log > /dev/null 2>&1 &
    SAM_PID=$!

    # Wait for the API to start (adjust sleep time as needed)
    sleep 5

    # Run integration tests against the local endpoint

    if ! API_GATEWAY_URL="http://127.0.0.1:3000/detect" uv run python -m pytest -q -m integration; then
        log "ERROR: API tests failed"
        kill $SAM_PID
        return 1
    fi

    # Wait for the process to be fully terminated
    kill $SAM_PID
    wait $SAM_PID 2> /dev/null

    return 0
}

test_deployment() {
    # Ensure ENV is set, though checking at top level
    log "Deploying ${ENV} application (est. 20s)"
    if ! sam deploy --config-env $ENV --no-fail-on-empty-changeset > .logs/deploy.log 2>&1; then
        log "ERROR: SAM deploy failed. Check .logs/deploy.log for details."
        cat .logs/deploy.log
        return 1
    fi

    sleep 5

    log "Running deployment tests..."
    export STACK_NAME="cerebro-${ENV}"
    export AWS_SAM_STACK_NAME=$STACK_NAME
    if $PYTHON_CMD -m pytest -q -m deployment; then
        return 0
    else
        return 1
    fi
}

publish() {
    log "Publishing prod application (est. 20s)"
    if ! sam deploy --config-env "prod" | tee .logs/publish.log; then
        log "ERROR: SAM deploy failed. Check .logs/publish.log for details."
        cat .logs/publish.log
        return 1
    fi
}

cleanup() {
    # Using exit 0 here might hide errors if called from an error trap,
    # but the trap in main catches SIGINT/SIGTERM.
    # If the script exits normally, we don't need a specific cleanup message unless resources are left.
    :
}

main() {
    # Initialize flags
    local run_publish=false
    local run_test_unit=false
    local run_test_integration=false
    local run_test_deployment=true

    trap cleanup SIGINT SIGTERM

    check_dependencies
    check_and_export_model

    # Parse arguments
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            -h|--help)
                help_function
                exit 0
                ;;
            -u|--unit-test)
                test_unit || { log "Unit tests failed"; exit 1; }
                exit 0
                ;;
            -i|--integration-test)
                validate_and_build || exit 1
                test_integration || { log "Integration tests failed"; exit 1; }
                exit 0
                ;;
            -d|--deployment-test)
                validate_and_build || exit 1
                test_deployment || { log "Deployment tests failed"; exit 1; }
                exit 0
                ;;
            -p|--publish)
                test_unit || { log "Unit tests failed"; exit 1; }
                validate_and_build || exit 1
                test_integration || { log "Integration tests failed"; exit 1; }
                test_deployment || { log "Deployment tests failed"; exit 1; }
                publish || { log "Publish failed"; exit 1; }
                exit 0
                ;;
            *)
                echo "Unknown parameter passed: $1"
                help_function
                exit 1
                ;;
        esac
    done
}

main "$@"
